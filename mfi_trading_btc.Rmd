---
title: "Trading BTC based on Volume Flow Indicator (VFI)"
author: "Mark Ziemann https://mdz-analytics.com"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    fig_width: 7
    fig_height: 7
theme: cosmo
---

Source: https://github.com/markziemann/cryptoblog/blob/main/vfi_trading_btc.Rmd

This report is distributed for FREE under the [MIT licence](https://github.com/markziemann/cryptoblog/blob/main/LICENSE),
but if you find it useful, consider a small tip.


XMR:4BGrdeAF5qyJQXjzWF4W5uCZF7WuwJU16BfPtgg1WJMnf33jZMtLvoF1jRtZBGpLtz5BQZaLYiBFJJC488anty64FB7SASD

## Intro

There are many indicators of market momentum, one of them is the volume flow indicator (VFI).

From ThinkOrSwin:

>The Volume Flow Indicator is a long-term trend following study which uses the same principle as 
On Balance Volume.
>However, instead of comparing two Close prices of adjacent bars, it compares change in typical 
price with a so-called "cut off" value based on standard deviation.


Default settings:

130 VFI Length

0.2 Coef

2.5 Volume cutoff

3 Smoothing Period

However I will be seeing whether other intervals perform better for BTC.

This page is designed to be updated daily - today's date is shown below.

```{r,lib}

suppressPackageStartupMessages({
  library("jsonlite")
  library("tidyverse")
  library("runner")
  library("quantmod")
  library("TTR")
  library("vioplot")
  library("kableExtra")
  library("parallel")
})

Sys.Date()

CORES=detectCores()/2

```

Reminder: this is not financial advice.

## Get data

Obtaining BTC historical data (daily) from CoinMarketCap.com from June 2013 to present.

```{r,getdata}

mydate <- Sys.Date()-1
URL=paste("https://web-api.coinmarketcap.com/v1/cryptocurrency/ohlcv/historical?symbol=BTC&convert=USD&interval=daily&time_start=2013-06-01&time_end=",mydate,sep="")
download.file(URL,destfile="btcdat.txt")
btcdat <- fromJSON("btcdat.txt")
price <- btcdat$data$quotes
price <- data.frame(price$time_close, price$quote$USD$high, price$quote$USD$low, price$quote$USD$close,
  price$quote$USD$volume, stringsAsFactors=FALSE)
colnames(price) <- c("date","high","low","close","volume")
price$date <- sapply(strsplit(as.character(price$date),"T"),"[[",1)
price <- subset(price,volume>0)

```

My DIY volume momentum indicator.

```{r,exp_vol}

price2 <- price
close <- price2$close
open <- close
close <- close[2:length(close)]
open <- open[1:length(close)]
pad <- c(0,0)
oc <- rbind(pad,cbind(open,close))
price2$open <- oc[,"open"]
price2 <- subset(price2,volume>0)
#price2$diff <- (price2$close - price2$open ) / price2$open * 100
price2$diff <- log(price2$close / price2$open)
price2$mavol <- SMA(price2$volume,n=20)
price2 <- price2[which(!is.na(price2$mavol)),]
price2$volwt <- price2$volume / price2$mavol
price2$ind <- price2$diff * price2$volwt
price2$maind <- SMA(price2$ind,n=50)
price2$maind2 <- SMA(price2$ind,n=100)
price2 <- price2[!is.na(price2$maind2),]

par(mfrow=c(2,1))
plot(price2$close ~ as.Date(price2$date),type="l",log="y",
  xlab="Date",ylab="price (USD)",main="USD price")
grid()

plot(price2$maind - price2$maind2 ~ as.Date(price2$date),type="l",col="blue",
  xlab="Date",ylab="MFI",main="MFI")
#lines(as.Date(price2$date), price2$maind2  , col="red"  )
abline(h=0,lwd=2)
grid()

par(mfrow=c(1,1))

par(mfrow=c(2,1))
plot(price2$close ~ as.Date(price2$date),type="l",log="y",
  xlab="Date",ylab="price (USD)",main="USD price")
grid()


plot(EMA(price2$ind,150) - EMA(price2$ind,200) ~ as.Date(price2$date),type="l",col="blue",
  xlab="Date",ylab="MFI",main="MFI")
#lines(as.Date(price2$date), EMA(sign(price2$ind),200)  , col="red"  )
abline(h=0,lwd=2)
grid()

par(mfrow=c(1,1))



```

## Calculate hodl returns

It's important to calculate the returns for simply holding the asset rather than actively trading.

The number shown here is the fold return on investment.
BTC has appreciated a lot since 2013!

```{r,hodl}

myend <- price[c(1,nrow(price)),4][2] 
mystart <- price[c(1,nrow(price)),4][1] 
hodl <- (myend - mystart) / mystart
hodl

```

## Basic look at the VFI indicator

Here we can see the VFI over the past 730 days, using the default settings.

n1=14d and n2=28d

It is extremely noisy.

```{r,mfi1,fig.height=10,fig.width=8}

price2 <- price
price2$mfi1 <- MFI(HLC=price[,2:4],volume=price$volume,n=14)
price2$mfi2 <- MFI(HLC=price[,2:4],volume=price$volume,n=28)

par(mfrow=c(2,1))
plot(price2$close ~ as.Date(price2$date),type="l",log="y",
  xlab="Date",ylab="price (USD)",main="USD price")
grid()

plot(price2$mfi1 ~ as.Date(price2$date),type="l",col="blue",
  xlab="Date",ylab="MFI",main="MFI")
lines(as.Date(price2$date), price2$mfi2  , col="red"  )
grid()

par(mfrow=c(1,1))

```

## Now with a longer period used

Using n1=100 and n2=200d.
Better but still really noisy.

```{r,mfi2,fig.height=10,fig.width=8}

price2 <- price
price2$mfi1 <- MFI(HLC=price[,2:4],volume=price$volume,n=100)
price2$mfi2 <- MFI(HLC=price[,2:4],volume=price$volume,n=200)

par(mfrow=c(2,1))
plot(price2$close ~ as.Date(price2$date),type="l",log="y",
  xlab="Date",ylab="price (USD)",main="USD price")
grid()

plot(price2$mfi1 ~ as.Date(price2$date),type="l",col="blue",
  xlab="Date",ylab="MFI",main="MFI")
lines(as.Date(price2$date), price2$mfi2  , col="red"  )
grid()

par(mfrow=c(1,1))

```

## Now trying a SMA to smooth the line

Using n1=100+100sma and n2=200+200sma. 
Better but the timing isn't that great.

```{r,mfi3,fig.height=10,fig.width=8}

price2 <- price
price2$mfi1 <- SMA(MFI(HLC=price[,2:4],volume=price$volume,n=100),n=100)
price2$mfi2 <- SMA(MFI(HLC=price[,2:4],volume=price$volume,n=200),n=200)

par(mfrow=c(2,1))
plot(price2$close ~ as.Date(price2$date),type="l",log="y",
  xlab="Date",ylab="price (USD)",main="USD price")
grid()

plot(price2$mfi1 ~ as.Date(price2$date),type="l",col="blue",
  xlab="Date",ylab="MFI",main="MFI")
lines(as.Date(price2$date), price2$mfi2  , col="red"  )
grid()

par(mfrow=c(1,1))

```

## Now trying a shorter SMA for less smoothing

Using n1=100 with 200SMA and n2=200 with 400 SMA

```{r,mfi4,fig.height=10,fig.width=8}

price2 <- price
price2$mfi1 <- SMA(MFI(HLC=price[,2:4],volume=price$volume,n=100),n=200)
price2$mfi2 <- SMA(MFI(HLC=price[,2:4],volume=price$volume,n=200),n=400)

par(mfrow=c(2,1))
plot(price2$close ~ as.Date(price2$date),type="l",log="y",
  xlab="Date",ylab="price (USD)",main="USD price")
grid()

plot(price2$mfi1 ~ as.Date(price2$date),type="l",col="blue",
  xlab="Date",ylab="MFI",main="MFI")
lines(as.Date(price2$date), price2$mfi2  , col="red"  )
grid()

par(mfrow=c(1,1))

```



## Another idea - look at the line gradient instead

That didn't work out.

```{r,mfi5,fig.height=10,fig.width=8}

price2 <- price
price2$mfi1 <- SMA(MFI(HLC=price[,2:4],volume=price$volume,n=100),n=200)
x <- price2$mfi1
x1 <- c(x,NA)
x2 <- c(NA,x)
grad <- x1 - x2
price2$grad <- grad[1:(length(grad)-1)]


par(mfrow=c(2,1))
plot(price2$close ~ as.Date(price2$date),type="l",log="y",
  xlab="Date",ylab="price (USD)",main="USD price")
grid()

plot(price2$mfi1 ~ as.Date(price2$date),type="l",col="blue",
  xlab="Date",ylab="MFI",main="MFI")
grid()

plot(price2$close ~ as.Date(price2$date),type="l",log="y",
  xlab="Date",ylab="price (USD)",main="USD price")
grid()

plot(price2$grad ~ as.Date(price2$date),type="l",col="blue",
  xlab="Date",ylab="MFI",main="MFI gradient")
grid()

par(mfrow=c(1,1))

```

## Now with a longer period used

```{r,mfi6,fig.height=10,fig.width=8}

price2 <- price
price2$mfi1 <- SMA(MFI(HLC=price[,2:4],volume=price$volume,n=100),n=100)
price2$mfi2 <- SMA(MFI(HLC=price[,2:4],volume=price$volume,n=200),n=200)

par(mfrow=c(2,1))
plot(price2$close ~ as.Date(price2$date),type="l",log="y",
  xlab="Date",ylab="price (USD)",main="USD price")
grid()

plot(price2$mfi1 ~ as.Date(price2$date),type="l",col="blue",
  xlab="Date",ylab="MFI",main="MFI")
lines(as.Date(price2$date), price2$mfi2  , col="red"  )
grid()

par(mfrow=c(1,1))

```

## Experiment with own formula

Let's try a new idea.


```{r,volind}



```

## MFI trading function

Here is the function for trading based on MFI indicator, buying when short interval indicator
goes above the longer interval line, and sell when it falls below.

All trades are executed at the end of the daily session (UTC midnight).

```{r,mfifunc1}

mymfi <- function(price,n1,n2,fee) {
  price2 <- price
  price2$mfi1 <- SMA(MFI(HLC=price[,2:4],volume=price$volume,n=n1),n=n1)
  price2$mfi2 <- SMA(MFI(HLC=price[,2:4],volume=price$volume,n=n2),n=n2)
  price2$higher <- price2$mfi1 > price2$mfi2
  yesterday <- price2$higher
  yesterday <- c(NA,yesterday)
  yesterday <- yesterday[1:(length(yesterday)-1)]
  price2$yesterday <- yesterday
  price2$trade <- price2$higher - price2$yesterday
  price2 <- price2[which(price2$trade!=0),]
  if ( price2$trade[1] == -1 ) { price2 <- price2[2:nrow(price2),] }
  if ( tail(price2,1)$trade ) { price2 <- price2[1:(nrow(price2)-1),] }
  buy <- subset(price2,trade==1)[,c("date","close")]
  colnames(buy) <- c("buy_date","buy_price")
  sell <- subset(price2,trade==-1)[,c("date","close")]
  colnames(sell) <- c("sell_date","sell_price")
  if( nrow(buy) != nrow(sell) ) {
    MIN=min(nrow(buy),nrow(sell))
    buy <- buy[1:MIN,]
    sell <- sell[1:MIN,]
  }
  trades <- cbind(buy,sell)
  trades$diff <- ( ( trades$sell_price - trades$buy_price ) / trades$buy_price ) +1 - ( 2 * fee )
  return(c(prod(trades$diff),nrow(trades)))
}

```

## Backtesting

Now let's go back in time to test the performance of the different interval strategies on the daily
timeframe, here are the ranges tested:

* n1: from 10 to 300 days

* n2: from 20 to 500 days

Let's assume a 0.1% exchange fee, as per binance current rate.

There are a lot of possibilities, so the best way to get a feel for the results is to see which combinations of parameters performed best using different
performance metrics.

```{r,backtest1}

fee=0.001

n1r <- seq(10,150,5)
n2r <- seq(100,500,5)
params <- expand.grid(n1r,n2r)
colnames(params) <- c("n1","n2")
params <- params[which( params$n1 < params$n2) ,]

res <- mclapply(X=1:nrow(params) , FUN=function(i) {
  n1=as.numeric(params[i,1])
  n2=as.numeric(params[i,2])
  mymfi(price,n1=n1,n2=n2,fee=fee)
} , mc.cores = CORES )
res <- as.data.frame(do.call(rbind, res))
colnames(res) <- c("returns","trades")
res2 <- cbind(params,res)
res2$returnspertrade <- res2$returns/res2$trades
res2$mean <- res2$returns^(1/res2$trades)

basic <- mymfi(price,n1=25,n2=13,fee=fee)
basic_returns <- basic[1]
basic_mean <- basic[1]^(1/basic[2])

```

Here are the strategies which had the highest mean return per trade.
These opportunities don't arise often but could be potential opportunities for leveraged trades.

```{r,backtest_res1}

head(res2[order(-res2$mean),],20) %>% kbl() %>%  kable_paper("hover", full_width = F)

```

Here are the strategies which had the highest overall returns.
This involves more frequent trading and the returns on each trade were smaller.
This is less optimal if trades are executed manually.

```{r,backtest_res2}

head(res2[order(-res2$returns),],20) %>% kbl() %>%  kable_paper("hover", full_width = F)

```

## Plots

Another approach to selecting "good" parameters could be to begin with the default values and then
aim to increase returns and decrease the number of trades executed.

The red dot in the chart below indicates the TSI with default interval values.
Data points to the upper right side of that dot are strategies with better performance.

```{r,plots1,fig.height=8,fig.width=8}

plot(res2$mean , res2$returns, log="y",xlab="mean ROI", ylab="total returns")
points(basic_mean,basic_returns,col="red",pch=19,cex=2)
abline(h=hodl,col="red")
grid()

plot(res3$mean , res3$returns, log="y",xlab="mean ROI", ylab="total returns")
points(basic_mean,basic_returns,col="red",pch=19,cex=2)
abline(h=hodl,col="red")
grid()

```

## Conclusions

## Session information

For reproducibility

```{r,sessioninfo}

sessionInfo()

```
